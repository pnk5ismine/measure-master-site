<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Measure Master — 사용법</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <link rel="preload" as="image" href="/images/mm_logo_small.jpg" />
  <style>
    :root { --bg:#0b0d12; --card:#121622; --muted:#9aa4b2; --pri:#5eead4; --border:#1e2230; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;background:var(--bg);color:#e7edf5}
    a{color:var(--pri);text-decoration:none} a:hover{text-decoration:underline}
    header,main,footer{max-width:1100px;margin:0 auto;padding:16px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .brand{display:flex;align-items:center;gap:10px}
    .logo-img{width:28px;height:28px;border-radius:6px;object-fit:contain;background:#0e1422}
    nav a{margin-left:16px;color:#cfd6e4}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:22px}
    h1{margin:8px 0 2px;font-size:22px}
    p.muted{color:var(--muted);margin:2px 0 0}
    .howtouse{ margin-top:10px; }

/* 그리드 기본(데스크톱 3열, 태블릿 2열) */
.howtouse-grid{
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
}
@media (max-width:1024px){
  .howtouse-grid{ grid-template-columns: repeat(2, 1fr); }
}

/* ✅ 데스크톱/태블릿: 카드 높이 고정(행 균일) */
@media (min-width:641px){
  .howtouse-item{ 
    display:block;            /* 안전 */
    aspect-ratio: 1 / 2;      /* 필요하면 3/4, 4/5 등으로 조절 가능 */
    position: relative;
    overflow: hidden;
  }
  .howtouse-item img{
    width:100%;
    height:100%;              /* 카드 높이에 맞춤 */
    object-fit: cover;        /* 크롭해서 균일 높이 유지 */
    display:block;
  }
}

/* 📱 모바일: 1열, 원본 비율 */
@media (max-width:640px){
  .howtouse-grid{ grid-template-columns: 1fr; }
  .howtouse-item{ aspect-ratio: auto; }
  .howtouse-item img{ height:auto; object-fit: contain; }
}
    .howtouse-item{ position:relative; display:block; border-radius:10px; overflow:hidden; background:#0f1320; aspect-ratio:1/2; border:1px solid var(--border); }
    .howtouse-item img{ width:100%; height:100%; object-fit:cover; display:block; image-rendering:auto; transition:transform .2s ease-out, opacity .2s ease-out; opacity:.98; }
    .howtouse-item:hover img{ transform:scale(1.02); opacity:1; }
    .overlay{ position:absolute; inset:0; pointer-events:none; }
    .olabel{ position:absolute; white-space:pre-wrap; color:#000; text-shadow:none; filter:none; }
    .anchor-topstart{ transform: translate(0,0); }
    .anchor-topcenter{ transform: translate(-50%,0); left:50%; }
    .anchor-topend{ transform: translate(-100%,0); }
    .debug .olabel { outline:1px dashed rgba(0,0,0,.35); }
    footer{margin:30px auto 60px;text-align:center;color:var(--muted);font-size:14px}
    /* JS 작동 확인용 토스트 */
    #ping{position:fixed;top:8px;right:8px;background:#16a34a;color:#fff;padding:6px 10px;border-radius:8px;z-index:99999;font:12px/1 system-ui}
    /* 03~06만 원본 비율 유지(크롭 금지) */
  .howtouse-item.ratio-free{ aspect-ratio: unset !important; }
  .howtouse-item.ratio-free img{
    height: auto !important;
    object-fit: contain !important; /* cover → contain */
  }
/* === 미리보기/모드 전환 툴바 === */
.howto-toolbar{
  display:flex; gap:8px; align-items:center; flex-wrap:wrap;
  margin:10px 0 12px; font-size:14px;
}
.howto-toolbar .mini{
  padding:6px 10px; border-radius:8px; border:1px solid #1e2230;
  background:#121622; color:#e7edf5; cursor:pointer;
}
.howto-toolbar label{display:flex; gap:6px; align-items:center}
.howto-toolbar input[type="number"], .howto-toolbar select{
  padding:6px 8px; border-radius:8px; border:1px solid #1e2230; background:#0f1320; color:#e7edf5;
}

/* === 라벨 에디터 패널 === */
#editorPanel{
  margin:8px 0 0; padding:12px; border:1px dashed #2a3042; border-radius:12px;
  background:#0f1320; display:none;
}
#editorPanel table{width:100%; border-collapse:collapse; font-size:13px}
#editorPanel th, #editorPanel td{border-bottom:1px solid #1e2230; padding:6px 8px; vertical-align:top}
#editorPanel input[type="text"], #editorPanel input[type="number"], #editorPanel select{
  width:100%; padding:6px 8px; border:1px solid #2a3042; border-radius:8px; background:#0b0f1c; color:#e7edf5;
}
#editorPanel .row-actions{display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-top:8px}
#editorPanel .mini{padding:6px 10px; border-radius:8px; border:1px solid #2a3042; background:#121622; color:#e7edf5; cursor:pointer}
#exportArea{width:100%; min-height:120px; margin-top:8px; padding:8px; background:#0b0f1c; color:#cfe3ff; border:1px solid #2a3042; border-radius:8px}

</style>

<style id="__howto_grid_lock">
/* 데스크톱/태블릿: 3열/2열, 행 순서 고정 */
@media (min-width:1025px){
  #howtoGrid.howtouse-grid{ display:grid !important; grid-template-columns:repeat(3,1fr) !important; gap:12px !important; }
}
@media (min-width:641px) and (max-width:1024px){
  #howtoGrid.howtouse-grid{ display:grid !important; grid-template-columns:repeat(2,1fr) !important; gap:12px !important; }
}
/* 카드 높이/이미지: PC는 예전처럼 고정 비율 + cover */
@media (min-width:641px){
  #howtoGrid .howtouse-item{ aspect-ratio:1/2 !important; position:relative; overflow:hidden; }
  #howtoGrid .howtouse-item img{ width:100%; height:100% !important; object-fit:cover !important; display:block; }
}
/* 모바일: 1열(기존 의도) */
@media (max-width:640px){
  #howtoGrid.howtouse-grid{ display:grid !important; grid-template-columns:1fr !important; gap:12px !important; }
  #howtoGrid .howtouse-item{ aspect-ratio:auto !important; }
  #howtoGrid .howtouse-item img{ height:auto !important; object-fit:contain !important; }
}
</style>


</head>
<body>
<header>
  <div class="brand">
    <img src="/images/mm_logo_small.jpg" alt="Measure Master" class="logo-img" width="28" height="28"
         loading="eager" fetchpriority="high"
         onerror="this.onerror=null; this.src='/images/mm_logo_small.png';" />
    <strong>Measure Master</strong>
  </div>
  <nav>
    <a href="/">홈</a>
    <a href="/howtouse.html">사용법</a>
    <a href="/reviews.html">사용후기</a>
    <a href="/privacy.html">개인정보처리방침</a>
  </nav>
</header>

<main>
  <section class="card howtouse">
    <h1>사용법</h1>
    <p class="muted">총 22장 · 이미지를 탭하면 원본이 새 탭에서 열립니다.</p>
    <div class="howto-toolbar">
      <label>모드
        <select id="modeSel">
          <option value="pc">PC</option>
          <option value="mo">모바일</option>
       </select>
     </label>
     <label>페이지
       <input id="pageSel" type="number" min="1" max="23" value="1">
     </label>
     <button id="btnPreview" class="mini" type="button">미리보기 켜기</button>
     <button id="btnEditor" class="mini" type="button">에디터 열기</button>
   </div>
   <div id="editorPanel"></div>
   <div id="howtoGrid" class="howtouse-grid"></div>
 </section>
</main>

<footer>
  © <span id="year"></span> Measure Master. All rights reserved.
</footer>

<script>
/* howtouse: PC/MO 분리 + 실시간 미리보기/간이 에디터 v=mo01 */
(function(){
  const GRID_ID       = "howtoGrid";
  const TOTAL_PAGES   = 23;
  const IMG_DIRS      = ["/images/howtouse", "/image/howtouse"];
  const IMG_PREFIX    = "howtouse";
  const IMG_EXTS      = ["jpg","png","jpeg","webp"];
  const OVERLAYS_JSON_PC = "/assets/data/howtouse_overlays_pc.json?v=pc28";
  const OVERLAYS_JSON_MO = "/assets/data/howtouse_overlays_mo.json?v=mo01";
  const STRINGS_JSON  = "/assets/data/strings_ko_pc.json?v=pc28";
  const BASE_H        = 600;

  const IS_MOBILE_VIEW = matchMedia('(max-width:640px)').matches;
  const OVERLAYS_JSON  = IS_MOBILE_VIEW
    ? "/assets/data/howtouse_overlays_mo.json?v=mo1"
    : "/assets/data/howtouse_overlays_pc.json?v=pc28";

  // 상태
  const state = {
    mode: window.matchMedia("(max-width:640px)").matches ? "mo" : "pc",
    overlays: null,    // {pages:[ [...], ... ]}
    strings: null,     // 공용
    page: 1,           // 현재 포커스 페이지(에디터용)
    // page->labels 빠른 접근 (원본 객체 참조 유지)
    pageMap: {},       // { "01": [labelObj, ...], ... }
  };

  // DOM
  const $ = s => document.querySelector(s);
  const gridEl      = () => document.getElementById(GRID_ID) || document.querySelector(".howtouse-grid");
  const toolbar     = { modeSel: $('#modeSel'), pageSel: $('#pageSel'),
                        btnPreview: $('#btnPreview'), btnEditor: $('#btnEditor'),
                        editorPanel: $('#editorPanel') };

  function createImage(num){
    const img = new Image();
    img.alt = `사용법 ${num}`;
    img.loading = "eager";
    const cands = [];
    for(const d of IMG_DIRS) for(const e of IMG_EXTS) cands.push(`${d}/${IMG_PREFIX}${num}.${e}`);
    let i=0;
    img.onerror = ()=>{ if(++i<cands.length) img.src=cands[i]; else img.onerror=null; };
    img.src = cands[i];
    return img;
  }

  function parseColorHex(hex){
    if(!hex) return null;
    let s=String(hex).trim();
    if(s.startsWith("0x")) s=s.slice(2);
    if(s.startsWith("#")) s=s.slice(1);
    if(s.length===8){ const a=parseInt(s.slice(0,2),16)/255, r=parseInt(s.slice(2,4),16), g=parseInt(s.slice(4,6),16), b=parseInt(s.slice(6,8),16); return `rgba(${r},${g},${b},${a})`; }
    if(s.length===6){ const r=parseInt(s.slice(0,2),16), g=parseInt(s.slice(2,4),16), b=parseInt(s.slice(4,6),16); return `rgb(${r},${g},${b})`; }
    return null;
  }
  function anchorClass(align="TopStart"){
    const a=String(align).toLowerCase();
    if(a.includes("center")) return "anchor-topcenter";
    if(a.includes("end"))    return "anchor-topend";
    return "anchor-topstart";
  }

  function layoutLabels(card, labels, STR){
    let ol = card.querySelector(".overlay");
    if(!ol){ ol=document.createElement("div"); ol.className="overlay"; card.appendChild(ol); }
    ol.innerHTML = "";

    const rect = card.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    const scale = H/BASE_H;

    (labels||[]).forEach(cfg=>{
      const el = document.createElement("div");
      el.className = "olabel " + anchorClass(cfg.align);
      // ✅ 에디터 연결 정보
      el.__cfgRef = cfg;                                // 객체 참조
      el.dataset.key   = cfg.key || "";                 // 키
      el.dataset.page  = card.querySelector(".overlay")?.dataset.page || "";
      el.dataset.index = String((ol.childElementCount || 0));  // 대략적 순번

      const text = (STR && STR[cfg.key]) || cfg.key || "";
      el.textContent = text;

      if(cfg.bold) el.style.fontWeight = "700";
      if(cfg.sizeSp) el.style.fontSize = cfg.sizeSp + "px";
      if(cfg.lineHeightSp) el.style.lineHeight = cfg.lineHeightSp + "px";
      if(cfg.textAlign) el.style.textAlign = ({Center:"center", End:"right", Start:"left"}[cfg.textAlign]||"left");
      const col = parseColorHex(cfg.colorHex); if(col) el.style.color = col;
      if(cfg.maxWidthPercent) el.style.maxWidth = (cfg.maxWidthPercent*W) + "px";

      if(typeof cfg.xPercent==="number" && typeof cfg.yPercent==="number"){
        el.style.left = (cfg.xPercent*100) + "%";
        el.style.top  = (cfg.yPercent*100) + "%";
      }else{
        const a = String(cfg.align||"").toLowerCase();
        const base = a.includes("center") ? W/2 : a.includes("end") ? W : 0;
        el.style.left = (base + (cfg.dx||0)*scale) + "px";
        el.style.top  = ((cfg.dy||0)*scale) + "px";
      }
      ol.appendChild(el);
    });
  }

  // pages -> {"01":[...], ...} (원본 객체 참조 유지 → 에디터에서 값 수정 즉시 반영)
  function buildPageMap(pages){
    const map = {}; let premCandidate = null;
    (pages||[]).forEach(group=>{
      const any = group.find(it=>it && typeof it.key === 'string');
      const key = any ? any.key : '';

      let m = key.match(/htu(\d{2})_/i);
      if (m){ map[m[1]] = group; return; }

      const anyWithDigits = group.find(it=>/\d{2}/.test(it.key||''));
      if (anyWithDigits){
        const m2 = (anyWithDigits.key||'').match(/(\d{2})/);
        if (m2){ map[m2[1]] = group; return; }
      }
      if (!premCandidate && group.some(it=>/^prem1_/i.test(it.key||''))) premCandidate = group;
    });
    if (!map["23"] && premCandidate) map["23"] = premCandidate;
    return map;
  }

  window.__howtouse_state = { map, overlays, strings };

  async function loadJson(url){
    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error(`HTTP ${r.status} @ ${url}`);
    return r.json();
  }

  async function loadData(){
    // 모드별 오버레이 고르기
    const overlayUrl = state.mode === 'mo' ? OVERLAYS_JSON_MO : OVERLAYS_JSON_PC;
    const [ov, str] = await Promise.all([
      loadJson(overlayUrl),
      state.strings ? Promise.resolve(state.strings) : loadJson(STRINGS_JSON)
    ]);
    state.overlays = ov || { pages: [] };
    state.strings  = str || {};
    state.pageMap  = buildPageMap(state.overlays.pages || []);
  }

  function renderGrid(){
    const container = gridEl();
    if(!container){ console.error("[howtouse] grid container not found"); return; }
    container.innerHTML = "";

    for(let i=1;i<=TOTAL_PAGES;i++){
      const num = String(i).padStart(2,"0");
      const a = document.createElement("a");
      a.className = "howtouse-item";
      a.target = "_blank"; a.rel="noopener";
      a.href = `${IMG_DIRS[0]}/${IMG_PREFIX}${num}.jpg`;

      const img = createImage(num);
      a.appendChild(img);

      const ol = document.createElement("div");
      ol.className = "overlay";
      ol.dataset.page = num;           // ✅ 에디터가 페이지 번호를 알아야 함
      a.appendChild(ol);

      container.appendChild(a);

      const labels = state.pageMap[num];
      if(labels){
        const render = ()=> layoutLabels(a, labels, state.strings);
        img.addEventListener("load", render);
        render();
        new ResizeObserver(render).observe(a);
      }
    }
  }

  // ============ 미리보기/에디터 ============
  function togglePreview(){
    const on = !document.body.classList.contains('debug');
    document.body.classList.toggle('debug', on);
    toolbar.btnPreview.textContent = on ? '미리보기 끄기' : '미리보기 켜기';
  }

  function openEditor(){
    renderEditor();
    toolbar.editorPanel.style.display = 'block';
    toolbar.btnEditor.textContent = '에디터 닫기';
  }
  function closeEditor(){
    toolbar.editorPanel.style.display = 'none';
    toolbar.btnEditor.textContent = '에디터 열기';
  }
  function toggleEditor(){
    const opened = toolbar.editorPanel.style.display === 'block';
    opened ? closeEditor() : openEditor();
  }

  function getPageLabels(p){
    const num = String(p).padStart(2,'0');
    return state.pageMap[num] || [];
  }

  function renderEditor(){
    const panel = toolbar.editorPanel;
    const labels = getPageLabels(state.page);
    const numStr = String(state.page).padStart(2,'0');

    const rowsHtml = labels.map((lb, idx)=>`
      <tr data-idx="${idx}">
        <td style="width:120px"><code>${lb.key||''}</code></td>
        <td><input type="number" step="0.0001" min="0" max="1" value="${(lb.xPercent??'')}" data-field="xPercent" placeholder="xPercent (0~1)"></td>
        <td><input type="number" step="0.0001" min="0" max="1" value="${(lb.yPercent??'')}" data-field="yPercent" placeholder="yPercent (0~1)"></td>
        <td>
          <select data-field="align">
            ${['TopStart','TopCenter','TopEnd'].map(v=>`<option value="${v}" ${lb.align===v?'selected':''}>${v}</option>`).join('')}
          </select>
        </td>
        <td><input type="number" step="1" value="${(lb.sizeSp??'')}" data-field="sizeSp" placeholder="sizeSp(px)"></td>
        <td><input type="number" step="1" value="${(lb.lineHeightSp??'')}" data-field="lineHeightSp" placeholder="lineHeightSp(px)"></td>
        <td><input type="number" step="0.001" min="0" max="1" value="${(lb.maxWidthPercent??'')}" data-field="maxWidthPercent" placeholder="maxWidth(0~1)"></td>
        <td><input type="text" value="${lb.colorHex??''}" data-field="colorHex" placeholder="#RRGGBB 또는 0xAARRGGBB"></td>
        <td style="text-align:center"><input type="checkbox" ${lb.bold?'checked':''} data-field="bold"></td>
      </tr>
    `).join('');

    panel.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:6px">
        <strong>에디터 · 페이지 ${numStr} (${labels.length}개 라벨)</strong>
        <div class="row-actions">
          <button type="button" class="mini" id="btnExport">JSON 내보내기</button>
          <button type="button" class="mini" id="btnReRender">미리보기 갱신</button>
        </div>
      </div>
      <table>
        <thead>
          <tr>
            <th>key</th><th>x%</th><th>y%</th><th>align</th><th>size</th><th>line</th><th>maxW%</th><th>color</th><th>bold</th>
          </tr>
        </thead>
        <tbody>${rowsHtml || `<tr><td colspan="9" class="muted">이 페이지에 라벨이 없습니다.</td></tr>`}</tbody>
      </table>
      <textarea id="exportArea" hidden readonly></textarea>
    `;

    // 입력 변경 → 즉시 state 업데이트 & 해당 카드만 리렌더
    panel.querySelectorAll('tbody tr').forEach(tr=>{
      tr.querySelectorAll('input,select').forEach(inp=>{
        inp.addEventListener('input', ()=>{
          const idx = Number(tr.dataset.idx);
          const field = inp.dataset.field;
          const label = labels[idx];
          if (!label) return;

          if (inp.type === 'checkbox'){
            label[field] = inp.checked;
          } else if (inp.type === 'number'){
            const v = inp.value === '' ? null : Number(inp.value);
            label[field] = (Number.isFinite(v) ? v : null);
          } else {
            label[field] = inp.value;
          }
          // 현재 페이지의 카드만 갱신
          rerenderCard(state.page);
        });
      });
    });

    panel.querySelector('#btnReRender')?.addEventListener('click', ()=>{
      rerenderCard(state.page);
    });

    panel.querySelector('#btnExport')?.addEventListener('click', ()=>{
      const ta = panel.querySelector('#exportArea');
      const out = JSON.stringify(state.overlays, null, 2);
      ta.value = out;
      ta.hidden = false;
      ta.select(); document.execCommand('copy');
      ta.blur();
      alert("현재 모드("+state.mode+") 오버레이 전체 JSON을 복사했습니다.\n서버의 "+(state.mode==='mo'?'howtouse_overlays_mo.json':'howtouse_overlays_pc.json')+"에 반영하세요.");
    });
  }

  // 특정 페이지 카드만 리렌더
  function rerenderCard(page){
    const container = gridEl(); if(!container) return;
    const idx = page - 1; if (idx < 0) return;
    const card = container.children[idx]; if (!card) return;

    const labels = getPageLabels(page);
    layoutLabels(card, labels, state.strings);
  }

  // ============ 초기화/이벤트 ============
  async function boot(){
    // 컨트롤 초기값
    if (toolbar.modeSel) toolbar.modeSel.value = state.mode;
    if (toolbar.pageSel) toolbar.pageSel.value = state.page;

    await loadData();
    renderGrid();

    toolbar.modeSel?.addEventListener('change', async ()=>{
      state.mode = toolbar.modeSel.value;
      await loadData();
      renderGrid();
      if (toolbar.editorPanel.style.display === 'block') renderEditor();
    });

    toolbar.pageSel?.addEventListener('input', ()=>{
      const v = Math.min(TOTAL_PAGES, Math.max(1, Number(toolbar.pageSel.value||1)));
      state.page = v;
      if (toolbar.editorPanel.style.display === 'block') renderEditor();
      // 카드 포커스 스크롤
      const container = gridEl(); const idx = v-1; const card = container?.children[idx];
      card?.scrollIntoView({behavior:'smooth', block:'center'});
    });

    toolbar.btnPreview?.addEventListener('click', togglePreview);
    toolbar.btnEditor?.addEventListener('click', toggleEditor);
  }

  // 최소 오버레이 CSS(없으면만 주입, 기존과 동일)
  (function injectCSS(){
    if (document.getElementById("__howtouse_min_css")) return;
    const s = document.createElement("style");
    s.id="__howtouse_min_css";
    s.textContent = `
      .overlay{position:absolute;inset:0;pointer-events:none}
      .olabel{position:absolute;color:#000;font-weight:400}
      .olabel.anchor-topcenter{transform:translateX(-50%)}
      .olabel.anchor-topend{transform:translateX(-100%)}
      .howtouse-item{position:relative}
    `;
    document.head.appendChild(s);
  })();

  window.addEventListener("load", boot);
})();
</script>

<script>
/* =========================
   HOWTO 미리보기·에디터 (drag handles)
   - ?editor=1 으로 자동 시작
   - 이동: 파란 원 핸들 드래그
   - 폭조절: 초록 사각 핸들 드래그 → maxWidthPercent 기록
   - 방향키: 좌/우/상/하 (Shift 키와 함께 누르면 5배)
   - Export: 현재 상태 JSON 다운로드(pc/mo 선택)
   ========================= */
(function(){
  const qs = new URLSearchParams(location.search);
  const START_ON = qs.get('editor') === '1';

  // 툴바 만들기
  function makeBar(){
    if (document.getElementById('howtoEditorBar')) return;
    const bar = document.createElement('div');
    bar.id = 'howtoEditorBar';
    bar.innerHTML = `
      <button id="htToggle">미리보기 ON</button>
      <label style="display:inline-flex;align-items:center;gap:6px">
        대상:
        <select id="htTarget">
          <option value="pc">PC JSON</option>
          <option value="mo">MO JSON</option>
        </select>
      </label>
      <button id="htExport">Export JSON</button>
      <label class="ht-import">Import JSON
        <input id="htImport" type="file" accept="application/json" hidden>
      </label>
      <span id="htHint" style="opacity:.8">파란 원: 이동 · 초록 사각: 폭</span>
    `;
    document.body.appendChild(bar);

    document.getElementById('htToggle').addEventListener('click', toggleEditing);
    document.getElementById('htExport').addEventListener('click', doExport);
    document.getElementById('htImport').addEventListener('change', doImport);
  }

  let editing = false;
  let current = null; // { el, cfg, overlay }

  function overlays(){
    return Array.from(document.querySelectorAll('.howtouse-item .overlay'));
  }

  function setEditing(on){
    editing = on;
    overlays().forEach(ol=>{
      ol.classList.toggle('editing', on);
    });
    if (on) decorateAll();
  }

  function toggleEditing(){
    setEditing(!editing);
    document.getElementById('htToggle').textContent = editing ? '미리보기 OFF' : '미리보기 ON';
  }

  // 레이블에 핸들(이동/리사이즈) 붙이기
  function decorate(el){
    if (!editing) return;
    if (el.classList.contains('ht-decorated')) return;
    el.classList.add('ht-decorated');
    el.style.position = 'absolute'; // 안전
    el.style.userSelect = 'none';

    // 이동 핸들
    const hMove = document.createElement('span');
    hMove.className = 'ht-handle ht-handle-move';
    el.appendChild(hMove);

    // 리사이즈 핸들
    const hSize = document.createElement('span');
    hSize.className = 'ht-handle ht-handle-resize';
    el.appendChild(hSize);

    hMove.addEventListener('mousedown', startDragMove);
    hMove.addEventListener('touchstart', startDragMove, {passive:false});
    hSize.addEventListener('mousedown', startResize);
    hSize.addEventListener('touchstart', startResize, {passive:false});

    // 선택 포커스
    el.addEventListener('mousedown', ()=>{ current = bind(el); highlight(el); });
    el.addEventListener('touchstart', ()=>{ current = bind(el); highlight(el); }, {passive:true});
  }

  function decorateAll(){
    overlays().forEach(ol=>{
      // 편집 중엔 포인터 가능
      ol.style.pointerEvents = 'auto';
      Array.from(ol.children).forEach(child=>{
        if (child.classList.contains('olabel')) decorate(child);
      });
    });
  }

  // DOM ↔ cfg 연결 확보
  function bind(el){
    const cfg = el.__cfgRef || null;
    const overlay = el.closest('.overlay');
    return { el, cfg, overlay };
  }

  function highlight(el){
    document.querySelectorAll('.olabel').forEach(x=>x.classList.toggle('ht-active', x===el));
  }

  // 유틸: 포인터 좌표
  function pt(e){
    if (e.touches && e.touches[0]) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
    return { x:e.clientX, y:e.clientY };
  }

  // ===== 이동 =====
  function startDragMove(e){
    e.preventDefault();
    e.stopPropagation();
    const el = this.parentElement;
    current = bind(el); highlight(el);
    if (!current.cfg) return;

    const start = pt(e);
    const rect  = current.overlay.getBoundingClientRect();
    const baseL = parseFloat(el.style.left || '0');
    const baseT = parseFloat(el.style.top  || '0');

    function onMove(ev){
      const p = pt(ev);
      let nx = baseL + (p.x - start.x);
      let ny = baseT + (p.y - start.y);
      nx = Math.max(0, Math.min(nx, rect.width));
      ny = Math.max(0, Math.min(ny, rect.height));
      el.style.left = nx + 'px';
      el.style.top  = ny + 'px';
      // cfg에 퍼센트로 기록
      current.cfg.xPercent = nx / rect.width;
      current.cfg.yPercent = ny / rect.height;
    }
    function onUp(){
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      window.removeEventListener('touchmove', onMove);
      window.removeEventListener('touchend', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp, {once:true});
    window.addEventListener('touchmove', onMove);
    window.addEventListener('touchend', onUp, {once:true});
  }

  // ===== 폭 조절(maxWidthPercent) =====
  function startResize(e){
    e.preventDefault();
    e.stopPropagation();
    const el = this.parentElement;
    current = bind(el); highlight(el);
    if (!current.cfg) return;

    const start = pt(e);
    const rect  = current.overlay.getBoundingClientRect();
    const startW = el.getBoundingClientRect().width;
    const startMax = (current.cfg.maxWidthPercent || (startW/rect.width));

    function onMove(ev){
      const p = pt(ev);
      const dx = p.x - start.x;
      let w = startW + dx;
      w = Math.max(20, Math.min(w, rect.width)); // 최소/최대 폭 제한
      el.style.maxWidth = w + 'px';
      current.cfg.maxWidthPercent = w / rect.width;
    }
    function onUp(){
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      window.removeEventListener('touchmove', onMove);
      window.removeEventListener('touchend', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp, {once:true});
    window.addEventListener('touchmove', onMove);
    window.addEventListener('touchend', onUp, {once:true});
  }

  // 방향키 미세 이동 (선택된 레이블만)
  window.addEventListener('keydown', (e)=>{
    if (!editing || !current?.el || !current?.cfg) return;
    const rect = current.overlay.getBoundingClientRect();
    const step = e.shiftKey ? 0.05 : 0.01; // 5% / 1%
    let xp = current.cfg.xPercent ?? (parseFloat(current.el.style.left)/rect.width);
    let yp = current.cfg.yPercent ?? (parseFloat(current.el.style.top)/rect.height);
    let changed = false;

    if (e.key === 'ArrowLeft')  { xp -= step; changed = true; }
    if (e.key === 'ArrowRight') { xp += step; changed = true; }
    if (e.key === 'ArrowUp')    { yp -= step; changed = true; }
    if (e.key === 'ArrowDown')  { yp += step; changed = true; }

    if (changed){
      xp = Math.max(0, Math.min(1, xp));
      yp = Math.max(0, Math.min(1, yp));
      current.cfg.xPercent = xp;
      current.cfg.yPercent = yp;
      current.el.style.left = (xp*rect.width) + 'px';
      current.el.style.top  = (yp*rect.height) + 'px';
      e.preventDefault();
    }
  });

  // Export / Import
  function snapshotPages(){
    // 가능한 한 원본 구조를 따라 {pages:[ [...page1 labels], [...page2], ... ]}
    // window.__howtouse_state.map 이 있으면 그걸, 없으면 DOM에서 재구성
    const pages = [];
    // 우선 페이지 번호 수집(작은→큰)
    const nums = Array.from(document.querySelectorAll('.overlay'))
      .map(ol => ol.dataset.page).filter(Boolean)
      .filter((v,i,arr)=>arr.indexOf(v)===i).sort((a,b)=>(+a)-(+b));

    nums.forEach(num=>{
      let labels = [];
      // map 이용 가능하면 깊은 복사
      if (window.__howtouse_state?.map?.[num]) {
        labels = window.__howtouse_state.map[num].map(x=>({ ...x }));
      } else {
        // DOM에서 최소필수만 복원
        const ol = document.querySelector(`.overlay[data-page="${num}"]`);
        if (ol){
          labels = Array.from(ol.querySelectorAll('.olabel')).map(el=>{
            const rect = ol.getBoundingClientRect();
            const left = parseFloat(el.style.left||'0');
            const top  = parseFloat(el.style.top ||'0');
            return {
              key: el.dataset.key || '',
              xPercent: left/rect.width,
              yPercent: top/rect.height,
              maxWidthPercent: (parseFloat((getComputedStyle(el).maxWidth||'0'))/rect.width) || undefined,
              align: 'TopStart'
            }
          });
        }
      }
      pages.push(labels);
    });
    return { pages };
  }

  function download(filename, text){
    const blob = new Blob([text], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }

  function doExport(){
    const target = (document.getElementById('htTarget').value || 'pc');
    const json = snapshotPages();
    download(`howtouse_overlays_${target}.json`, JSON.stringify(json, null, 2));
  }

  async function doImport(ev){
    const f = ev.target.files?.[0]; if (!f) return;
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      if (!obj?.pages) throw new Error('잘못된 JSON 형식');
      // 상태에 반영
      if (!window.__howtouse_state) window.__howtouse_state = {};
      // buildMap 없이도 페이지 순서대로 매핑
      const map = {};
      obj.pages.forEach((arr, i)=>{
        const num = String(i+1).padStart(2,'0');
        map[num] = arr;
      });
      window.__howtouse_state.map = map;
      // 화면에 즉시 반영: 기존 overlay 비우고 다시 그리기
      overlays().forEach(ol=>{
        const num = ol.dataset.page;
        const labels = map[num] || [];
        ol.innerHTML = '';
        applyLabels(ol, labels);
      });
      if (editing) decorateAll();
      alert('임포트 적용 완료 (미리보기 기준). 서버 파일을 교체해야 영구 반영됩니다.');
    }catch(err){
      alert('임포트 실패: ' + (err.message||err));
    }finally{
      ev.target.value = '';
    }
  }

  // 최소 렌더러(레이아웃) 복제: xPercent/yPercent, maxWidthPercent 중심
  function applyLabels(overlay, labels){
    const card = overlay.closest('.howtouse-item');
    const rect = overlay.getBoundingClientRect();
    const W = rect.width;

    labels.forEach(cfg=>{
      const el = document.createElement('div');
      el.className = 'olabel anchor-topstart';
      el.textContent = (window.__howtouse_state?.strings?.[cfg.key]) || cfg.key || '';

      if (cfg.bold) el.style.fontWeight = "700";
      if (cfg.sizeSp) el.style.fontSize = cfg.sizeSp + "px";
      if (cfg.lineHeightSp) el.style.lineHeight = cfg.lineHeightSp + "px";
      if (cfg.textAlign) el.style.textAlign = ({Center:"center", End:"right", Start:"left"}[cfg.textAlign]||"left");
      if (cfg.colorHex){
        let s=String(cfg.colorHex).trim();
        if(s.startsWith("0x")) s=s.slice(2);
        if(s.startsWith("#")) s=s.slice(1);
        if(s.length===8){ const a=parseInt(s.slice(0,2),16)/255, r=parseInt(s.slice(2,4),16), g=parseInt(s.slice(4,6),16), b=parseInt(s.slice(6,8),16); el.style.color=`rgba(${r},${g},${b},${a})`; }
        if(s.length===6){ const r=parseInt(s.slice(0,2),16), g=parseInt(s.slice(2,4),16), b=parseInt(s.slice(4,6),16); el.style.color=`rgb(${r},${g},${b})`; }
      }
      if (cfg.maxWidthPercent) el.style.maxWidth = (cfg.maxWidthPercent*W) + 'px';

      // 위치
      const xp = (typeof cfg.xPercent === 'number') ? cfg.xPercent : 0;
      const yp = (typeof cfg.yPercent === 'number') ? cfg.yPercent : 0;
      el.style.left = (xp*W) + 'px';
      el.style.top  = (yp*overlay.getBoundingClientRect().height) + 'px';

      // 에디터 연결 정보
      el.__cfgRef = cfg;
      el.dataset.key   = cfg.key || '';
      el.dataset.page  = overlay.dataset.page || '';
      el.dataset.index = String(overlay.childElementCount || 0);

      overlay.appendChild(el);
    });
  }

  // 레이아웃이 다시 그려져도 핸들이 살아있게 Mutation 감시
  const mo = new MutationObserver(() => { if (editing) decorateAll(); });
  mo.observe(document.body, { subtree:true, childList:true });

  // 초기화
  window.addEventListener('load', ()=>{
    makeBar();
    if (START_ON){
      setEditing(true);
      document.getElementById('htToggle').textContent = '미리보기 OFF';
    }
  });
})();
</script>

<style>
/* ====== 에디터용 스타일 ====== */
#howtoEditorBar{
  position:fixed; right:12px; bottom:12px;
  background:#111827; color:#e5e7eb;
  border:1px solid #374151; border-radius:12px;
  padding:8px 10px; z-index:99999;
  display:flex; align-items:center; gap:10px;
  box-shadow:0 4px 10px rgba(0,0,0,.25);
}
#howtoEditorBar button{ background:#2563eb; color:#fff; border:none; border-radius:8px; padding:6px 10px; cursor:pointer; }
#howtoEditorBar select{ background:#0f172a; color:#e5e7eb; border:1px solid #374151; border-radius:6px; padding:4px 6px; }
#howtoEditorBar .ht-import{ background:#0f172a; border:1px dashed #475569; color:#e5e7eb; border-radius:8px; padding:4px 8px; cursor:pointer; }

.overlay.editing{ pointer-events:auto; }
.overlay.editing .olabel{ pointer-events:auto; outline:1px dashed rgba(37,99,235,.45); }
.olabel.ht-active{ outline:2px solid rgba(37,99,235,.9); }

.olabel .ht-handle{
  position:absolute; width:12px; height:12px;
  border:2px solid #fff; box-shadow:0 1px 2px rgba(0,0,0,.3);
}
.olabel .ht-handle-move{ top:-8px; left:-8px; background:#2563eb; border-radius:999px; cursor:grab; }
.olabel .ht-handle-resize{ right:-8px; bottom:-8px; background:#10b981; border-radius:2px; cursor:se-resize; }
</style>

</body>
</html>
